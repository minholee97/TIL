### big-O, big-Ω, big-θ,

#### big-O
- 어떤 로직이 수행되는 시간의 상한을 의미
- 예를 들어, N 크기 배열의 모든 원소를 출력하는데 걸리는 시간을 big-O로 나타내면 O(N)이라 할 수 있지만, 보다 큰 O(N^2), O(N^3)도 가능하다
- 표시된 시간보다 오래걸리지 않는다는 것을 의미

#### big-Ω
- 어떤 로직이 수행되는 시간의 하한을 의미
- 예를 들어, N 크기 배열의 모든 원소를 출력하는데 걸리는 시간을 big-O로 나타내면 Ω(N)이라 할 수 있지만, 보다 작은 Ω(logN), Ω(1)도 가능하다
- 표시된 시간보다 빠를 수 없다는 것을 의미

#### big-θ
- big-O, big-Ω 둘을 합친 것으로 O(N)이면서 Ω(N)이면 θ(N)이라고 할 수 있다.

> 주로 big-O 표기법을 많이 사용함

#### 상수항 무시
- big-O는 단순히 증가하는 비율을 나타내므로 O(N)이 O(1)보다 빠른 경우가 있을 수 있음
- 두 개의 작업이 N번 루프안에 있는 경우, 하나의 작업이 N번 루프안에 있고 두 번 나타나는 경우
- 위 두 경우는 각각 O(N), O(2N)이라고 생각할 수 있지만 어셈블리 단계에서의 명령어 수나 컴파일 단계 등 고려해야 할 점이 많다
- 결론은 big-O 표기법은 어디까지나 수행시간이 어떻게 변화하는지 표현해주는 도구이며 상수항은 무시한다.

#### 지배적이지 않은 항 무시
- O(N^2 + N) => O(N^2) , N은 지배적이지 않음 (사실상 상수항)

#### 참고
- A작업이 끝나고 B작업을 이어서 한다면 시간복잡도는 O(A + B)임
- A작업을 할때마다 B작업을 수행한다면 시간복잡도는 O(A * B)임

#### 상환시간
- ArrayList는 용량이 꽉차면 기존보다 두 배 더 큰배열을 만들고 이전 배열의 모든 원소를 새 배열로 복사함
- 이 때 삽입, 삭제 시간은? 1) 배열이 꽉차있으면 O(N), 2) 자리가 있으면 O(1)
- 1의 경우는 거의 발생안하므로 분할 상환으로 계산가능
- 배열의 크기가 2의 승수가 되었을 때 용량이 두배로 증가
- 1,2,4,8,16,...,X에서 증가하므로 1,2,4,8,16,...,X만큼 복사가 일어남
- 1+2+4+8+16+...+X => X+X/2+X/4+X/8+...+1 => 대략 2X
- X번 삽입 시 필요한 시간은 O(2X)가 되고 한 번 삽입에 O(1)이 소요됨
 
#### log N 수행시간
- 이진탐색 (중간 값을 기준으로 좌, 우로 나누어 필요한 부분만 재탐색하는 알고리즘)
- N개를 탐색한다면 N, N/2, N/4, N/8... 이렇게 범위가 줄어듬
- N=16일 때, 16,8,4,2,1
- 반대로 1에서 2를 k번 곱했을 때 N이 되는지 구하려면 2^k = N에서 양변에 로그를 취함
- logN = k

#### 재귀적 수행시간
- 함수내에서 재귀적으로 함수가 두번씩 호출된다면?
- O(2^N), 즉 O(분기^깊이)로 표현됨
- 로그와 달리 지수의 밑은 무시하면 안됨


#### QUIZ
- 여러 개의 문자열로 구성된 배열을 각각의 문자열을 정렬하고 전체 문자열을 사전순으로 정렬한다고 했을 때 시간복잡도?
- 우선 변수를 정의해야한다
- 가장 길이가 긴 문자열의 길이를 s, 배열의 길이를 a라고 한다
- 각 문자열을 정렬하는데 O(slogs) 소요
- 1) a개의 문자열 정렬에 O(a * slogs) 소요
- 2) 두 개의 문자열을 비교하는데 O(s) 소요, 모든 문자열 비교에 O(aloga)번 소요 => O(a * sloga) 소요
- 최종적으로 1) 2)를 더하면 O(a * s(loga+logs)) 소요

```java

```
