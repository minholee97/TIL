### 1. 소켓 작성
#### 1. 프로토콜 스택의 내부 구성
- 프로토콜 스택 윗 부분에는 TCP, UDP 프로토콜이 있고 아랫 부분에는 IP 프로토콜이 있다
- TCP : 브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송, 수신할 경우
- UDP : DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송, 수신할 경우
- IP : 인터넷에서 데이터를 운반할 때 데이터를 작게 나눈 패킷이라는 형태로 운반하는데 패킷을 상대까지 운반하는 역할을 수행
- IP 안에는 ICMP와 ARP 프로토콜을 다루는 부분이 있음
- ICMP는 패킷을 운반할 때 발생하는 오류를 통지, ARP는 IP 주소에 대응하는 MAC 주소를 조사
#### 2. 소켓은 통신 제어용 제어 정보
- 프로토콜 스택 내부에는 제어 정보를 기록하는 메모리 영역을 가지고 있음
- 통신 상대의 IP 주소, 포트번호, 통신 진행 상태, 응답 여부 등
- 제어 정보가 기록된 메모리 영역을 소켓이라고 하고 프로토콜 스택은 소켓을 참조하면서 움직임
#### 3. Socket을 호출했을 때 동작
- socket 호출 시 소켓의 제어 정보를 기록하는 메모리 영역을 확보하고 디스크립터를 반환함
- 디스크립터는 프로토콜 스택 내부에 있는 다수의 소켓 중 어느 것을 가리키는지 나타내는 번호표 같은 정보
- 이후 애플리케이션이 디스크립터를 사용하여 데이터 송, 수신 동작을 의뢰
### 2. 서버 접속
#### 1. 접속의 의미
- IP 주소와 포트 번호를 소켓(프로토콜 스택)에 저장한다
- 서버측과 제어 정보를 주고 받아 송, 수신할 수 있는 상태를 만든다
- 송, 수신하는 데이터를 일시적으로 저장하는 버퍼 메모리를 확보한다
#### 2. 제어정보를 기록한 헤더 배치
- 제어정보를 가진 헤더는 서버와 클라이언트가 대화할 때마다 주고 받는 패킷 앞에 배치됨
- TCP 헤더, MAC 헤더, IP 헤더 (층마다 헤더가 있음)
- 헤더에 기록된 제어정보를 통해 대화가 이루어짐
- TCP 헤더 : 송신처 포트 번호, 수신처 포트 번호, 시퀀스 번호, ACK 번호, 데이터 오프셋, 컨트롤 비트 등
- 접속 단계에서는 데이터가 없으므로 패킷이 헤더로만 이루어짐
- 소켓에도 기록되는 제어정보가 있음 (애플리케이션에서 통지된 정보, 송, 수신 현황), 이 정보를 통해 프로토콜 스택이 움직임
- 결론적으로 통신 동작에 이용하는 제어 정보는 헤더에 기입되는 정보와, 소켓에 기록되는 정보 두 가지가 있음
#### 3. 접속 동작의 실체
- 애플리케이션이 connect() 호출로 접속의 시작
- 여기에 서버측 IP 주소, 포트 번호를 쓰면 프로토콜 스택의 TCP 담당 부분에 전달되고 서버의 TCP 담당 부분과 제어 정보를 주고 받음
- 이 과정은 먼저 데이터 송, 수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 만듬 (포트번호가 중요)
- 따라서 송, 수신측의 소켓을 지정할 수 있고 컨트롤 비트 중 SYN 비트를 1로 만듬
- TCP 헤더가 완성되면 IP 담당 부분에 건네주어 송신을 의뢰
- 서버의 IP 담당 부분에서 TCP 담당 부분에게 건네주고 TCP 담당 부분은 헤더를 조사하여 접속을 기다리는 소켓 중 기록된 포트 번호에 해당하는 소켓을 찾음
- 찾아내면 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태로 바뀌고 응답을 돌려줌
- 응답은 SYN 비트를 1, ACK 비트를 1로 만든 헤더를 만들어서 IP 담당 부분에게 의뢰
- 그러면 패킷이 클라이언트에게 돌아오고 SYN 비트를 확인하여 접속 성공을 확인하고 ACK 비트를 1로 만든 TCP 헤더를 서버에 전송
- 이로써 소켓은 데이터를 송, 수신할 수 있는 상태가 됨
### 3. 데이터 송수신
#### 1. 프로토콜 스택에 HTTP Request 메시지를 전송
- 애플리케이션이 write() 호출로 전송이 시작
- 참고로 프로토콜 스택은 데이터의 내용이 뭔지 모르고 write 호출시 지정된 길이만큼 1바이트씩 바이너리 데이터가 나열되어 있다고 인식함
- 프로토콜 스택은 자체 메모리 버퍼에 전달받은 데이터를 저장함
- 곧바로 보내지 않는 이유는 애플리케이션에서 작은 데이터를 여러번 write 해서 보낼경우 작은 패킷이 많아지므로 비효율적
- 그래서 어느 정도 저장하고 보내도록 버퍼에 저장하는데 언제 보낼지 판단하는 요소는 데이터의 크기와 타이밍임
- 프로토콜 스택은 MTU라는 매개변수를 바탕으로 크기에 대해 판단함
- MTU는 한 패킷의 최대 길이로 이더넷의 경우 보통 1500바이트임
- 패킷의 맨앞에 헤더를 제외하면 1460바이트가 되는데 이를 MSS라고 함
- 받은 데이터가 MSS를 초과하거나 가까워지면 데이터를 송신함
- 나머지 판단요소는 타이밍임
- 애플리케이션의 write 호출 주기가 길면 MSS에 가깝게 저장할때까지 오래걸림
- 따라서 프로토콜 스택의 내부에 타이머가 있어서 일정 시간 경과 후 자동으로 패킷을 송신함
- 또 하나는 애플리케이션 측에서 송신을 의뢰할 때 즉시 보내도록 옵션을 지정할 수 있음
#### 2. 데이터가 클 때는 분할하여 보냄
- HTTP Request 메시지는 보통 길지 않으므로 한 패킷에 들어가는데 폼을 사용해서 긴 데이터를 보내는 경우 한 패킷에 안들어감
- 이 경우 송신 버퍼는 MSS 길이를 초과하므로 다음 데이터를 기다릴 필요 없이 버퍼의 데이터를 앞에서 부터 MSS 크기에 맞게 잘라서 조각 하나씩 패킷에 넣어 송신함
- 각 패킷에 TCP 헤더를 부가하고 IP 담당 부분에 건네서 송신
#### 3. ACK 번호를 사용해서 패킷이 도착했는지 확인
- 송신하기 전, 데이터를 분할할 때 앞에서부터 몇 바이트에 해당하는지 셈 => 시퀀스 번호
- 시퀀스 번호를 TCP 헤더에 기록해서 전송하면 수신측은 이전에 수신한 데이터와 비교하는 것으로 누락을 알릴 수 있고
- 현재까지의 데이터를 합쳐서 몇 번째 바이트까지 수신한 건지 계산해서 TCP 헤더의 ACK 번호에 기록해서 알려줌
- ACK 번호를 되돌려주는 동작을 수신 확인 응답이라고 하며 어디까지 수신했는지 확인할 수 있음
- 실제로 시퀀스 번호는 1부터 시작하지 않고 난수로 시작을 하는데 접속 단계에서 SYN 패킷을 주고받는 과정에서 난수를 교환함
- 접속 과정 리마인드 (3-way-handshake)
- 1) SYN flag : 1, Sequence Number : 클라이언트쪽 난수
- 2) SYN flag : 1, ACK flag : 1, Sequence Number : 서버쪽 난수, Acknowledgment Number : 클라이언트쪽 난수 + 1
- 3) ACK flag : 1, Sequence Number : 클라이언트쪽 난수 + 1, Acknoledgement Number : 서버쪽 난수 + 1
- 서로 상대방이 보내는 값에 + 1을 해서 응답하면 서로의 존재를 인지하고 있음을 알 수 있고 논리적으로 연결이 됨
- TCP 에서는 송신한 패킷을 버퍼에 보관해두었다가 대응하는 ACK 번호가 돌아오지 않으면 재전송하는 것으로 안정적인 전송이 가능함
- 도착하지 않으면 다시보내기 때문에 네트워크의 어디에서 오류가 발생하더라도 전부 검출해서 회복처리를 취할 수 있음
- 이렇게 TCP가 무조건 송신을 성공하기 때문에 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 취하지 않음 (오류를 검출하면 해당 패킷 버림)
- 하지만 송신 도중의 케이블 분리나 서버가 다운되는 것처럼 어쩔 수 없는 경우에는 몇 번 재전송을 하다가 전망이 없는 것으로 보고 송신을 종료하고 애플리케이션에게 오류를 통지함
#### 4. 패킷 평균 왕복 시간으로 ACK 번호 대기시간을 조정
- ACK가 돌아오기까지 대기하는 시간을 타임아웃 값이라고 함
- ACK가 빨리 안돌아오면 재전송 하기 때문에 대기시간이 적절해야 함
- 그래서 TCP는 대기 시간을 동적으로 변경하는데 항상 ACK가 돌아오는 시간을 계측하다가 빨리 돌아오면 시간을 짧게, 늦으면 시간을 길게 설정함 (컴퓨터의 시간 계측은 정밀도가 낮으므로 너무 짧은 시간에 ACK가 돌아오면 정확하지가 않음, 그래서 최소값이 0.5초~1초로 정해져 있음)
#### 5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리
- 한 개의 패킷을 보내고 기다리는 건 낭비
- 윈도우라는 개념으로 여러개의 패킷을 보냄
- 수신측의 능력을 초과하지 않도록 수신측에서 수신 버퍼의 남은 공간을 TCP 헤더에 윈도우 필드에 써서 송신측에게 알리는 것으로 조절
- 수신 가능한 데이터의 최대값을 윈도우 사이즈라고 부르며 보통 수신측의 버퍼 메모리와 같은 크기
#### 6. ACK 번호와 윈도우를 합승
- ACK 번호 통지는 데이터를 수신한 직후 발생
- 윈도우 통지는 수신 처리가 완료되어 버퍼 공간이 비워졌을 때 발생
- 수신측은 통지할 때 잠시 기다리다가 다음 통지가 오면 하나의 패킷에 묶어서 보냄
- ACK와 윈도우는 묶어서 보내고 복수의 ACK나 복수의 윈도우는 제일 마지막의 통지만 보냄
#### 7. HTTP 응답 메시지를 수신
- 브라우저가 송신을 요청한 뒤 프로토콜 스택은 응답 메시지가 올 때까지 다른 작업을 수행
- 응답 메시지가 도착하면 해당 패킷의 TCP 헤더를 조사해서 누락이 없는지 검사하고 이상이 없으면 ACK 번호를 반송함
- 데이터 조각을 수신 버퍼에 일시 보관하고 조각을 연결해서 애플리케이션이 지정한 메모리 영역에 기록한 후 윈도우를 송신측에게 통지
### 4. 서버에서 연결을 끊어 소켓 말소
#### 1. 데이터 보내기를 완료하면 연결을 끊음
- 서버측이 먼저 close를 호출하면 프로토콜 스택이 TCP 헤더를 만들고 컨트롤 비트의 FIN 비트를 1로 설정하고  IP 담당 부분에 송신 의뢰
- 클라이언트측에서 ACK 응답을 보내고 데이터를 다 받았다면 FIN 응답을 보냄
- 서버에서 ACK 응답을 보냄
#### 2. 소켓을 말소
- 서버와의 대화가 끝나면 소켓을 말소하지만 새 소켓이 같은 포트번호가 할당될 수 있으므로 패킷 재전송 시간이 지나고 말소시킴
#### 3. 데이터 송, 수신 동작을 정리
- 1) 소켓을 만들면 서버를 향해 접속 동작을 수행
- 2) SYN을 1로 만든 TCP 헤더를 보내는데 시퀀스 번호와 윈도우 크기도 같이 보냄
- 3) 서버는 ACK(SYN값 + 1) 응답과 SYN을 1로만든 헤더, 시퀀스 번호와 윈도우를 보냄
- 4) 클라이언트는 ACK(SYN값 + 1) 응답을 보냄
- 5) 송, 수신 단계 수행, 리퀘스트 메시지를 적당한 크기로 조각
- 6) TCP 헤더를 부가하여 서버에 전송
- 7) TCP 헤더에는 송신 데이터가 몇 번쨰 바이트부터 시작되는지 시퀀스 번호가 기록되어있음
- 8) 서버에 도착하면 ACK 번호를 돌려주고 버퍼에 공간이 생기면 윈도우도 통지해 줌
- 9) 서버가 응답 메시지 보내기를 완료하면 연결 끊기 동작에 들어감
- 10) 웹의 경우 서버에서 연결 끊기 동작에 들어감(HTTP 1.1의 경우 클라이언트에서도 들어갈 수 있음)
- 11) 서버에서 FIN을 보내면 클라이언트에서 ACK를 보냄
- 12) 클라이언트에서 FIN을 보내고 서버에서 ACK를 보내면 잠시 기다렸다가 소켓이 말소
### 5. IP와 이더넷의 패킷 송, 수신
#### 1. 패킷의 기본
- TCP 에서 받은 패킷은 헤더와 데이터 두 부분으로 구성됨
- 헤더엔 수신처의 주소가 있음 (포트 번호)
- IP 패킷 : IP 헤더 + TCP 헤더 + 데이터 조각
- 이더넷 패킷 : MAC 헤더 + IP 헤더 + TCP 헤더 + 데이터 조각
- 송신처에서 수신처까지 중계장치(허브, 라우터)들을 거쳐감
- 중계장치는 내부에 어느 수신처가 어디에 있는지 기록된 테이블이 있고 이것과 헤더에 기록된 수신처 정보를 결합하여 목적지를 판단하고 분배함
#### 2. 패킷 송, 수신 동작의 개요
- TCP 담당 부분은 TCP 헤더를 데이터 조각에 붙여서 IP 담당에게 전달
- IP 담당 부분은 MAC 헤더와 IP 헤더를 붙여서 네트워크용 하드웨어인 LAN 어댑터에게 전달
- LAN 어댑터에게 전달된 패킷은 0과 1로 이루어진 이진 디지털 데이터이고 LAN 어댑터에 의해 전기 신호로 바뀌어 케이블에 송출됨
- 신호는 허브나 라우터 등의 중계장치에 도착하고 중계장치가 상대가 있는 곳까지 패킷을 전달
#### 3. 수신처 IP 주소를 기록한 IP 헤더
- IP 헤더 : 송신처 IP 주소, 수신처 IP 주소, 프로토콜 번호 등
- 수신처 IP 주소는 통신 상대의 IP 주소 (애플리케이션에서 통지한 것)
- 송신처 IP 주소는 송신처의 LAN 어댑터를 판단
#### 4. 이더넷용 MAC 헤더
- MAC 헤더 : 송신처 MAC 주소, 수신처 MAC 주소, 이더 타입
- IP의 경우 IP 헤더 뒤에 이어지는 것이 패킷의 내용물이고 내용물의 출처를 프로토콜 번호로 나타냄
- 이더넷은 MAC 헤더 뒤에 이어지는 것이 패킷의 내용물이고 내용물이 무엇인지 이더 타입으로 나타냄
- 송신처의 MAC 주소는 LAN 어댑터의 ROM에 기록되어 있고 OS 기동시 읽어옴
- 수신처의 MAC 주소는 IP 주소와 달리 아직은 모르는 상태
- 라우팅 테이블에서 선택된 행의 Gateway 항목에 기록된 IP 주소의 기기가 상대가 됨
- 상대는 알았는데 상대의 MAC 주소는 모르는 상태이므로 MAC 주소를 조사하는 동작 수행
