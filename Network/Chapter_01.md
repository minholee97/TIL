### 1. HTTP 리퀘스트 메시지 작성
#### 1. URL 입력
- URL : 자원이 어디있는지 알려주는 규약
- http: 뿐만아니라 file:, mailto: 등이 있음
- 브라우저는 웹 서버에 엑세스하는 클라이언트 역할 말고도 파일을 업로드/다운로드하는 FTP클라이언트나 메일의 클라이언트 역할을 수행할 수 있기 때문에 여러 종류의 URL이 준비되어 있음
- http:, ftp:, mailto: 는 엑세스하는 방법을 나타내는 프로토콜이라고함 (file: 은 아님)
#### 2. 브라우저는 URL을 해독
- 브라우저는 다음과 같이 URL을 분해하여 해독함
- https:(프로토콜) + // + 웹 서버명(도메인명) + / + 디렉토리 명 + / + 파일명
- 예시)
- (a) http://www.lab.cyber.co.kr/dir/  =>  파일명 생략, /dir/index.html을 엑세스함
- (b) http://www.lab.cyber.co.kr/      =>  파일명 생략, /index.html을 엑세스함
- (c) http://www.lab.cyber.co.kr       =>  파일명, 디렉토리명 생략, /index.html을 엑세스함
- (d) http://www.lab.cyber.co.kr/whatisthis  =>  루트 디렉토리 밑에 whatisthis가 파일인지 디렉토리인지 확인 
- => URL을 해독하면 어디에 엑세스해야 하는지 판명됨

#### 3. HTTP 리퀘스트 메시지를 만듬
- 리퀘스트 메시지는 '무엇을' + '어떻게' 로 구성되어있음
- '무엇을' : 자원의 URI(파일명, CGI)
- '어떻게' : 메소드(GET, POST, PUT, DELETE)
- 리퀘스트 메시지를 웹 서버에 전송하면 응답 메시지가 돌아옴
- 응답 메시지는 실행 결과를 나타내는 스테이터스 코드, 응답 문구와 요청한 데이터가 담겨있음
- 만약 응답 html안에 영상이 있으면 영상 태그를 비워두고 표시한 후에 영상 태그의 정보를 바탕으로 서버에 영상을 요청함
- 영상을 응답 받아서 비워둔 자리에 표시함
- 리퀘스트 메시지에 URI는 한 개만 표시할 수 있으므로 파일을 한 번에 하나씩 읽을 수 밖에 없음
- 만약 3개의 영상이 포함된 html을 요청한다면 총 4번의 리퀘스트 메시지를 웹 서버에 전송하게 
#### 리퀘스트 메시지의 구조
 1) 리퀘스트 라인 : <메소드> \<URI> <HTTP 버전>
 2) 메시지 헤더 : 리퀘스트의 부가 정보 (날짜, 연결 유지 여부, 본문 인코딩 형식)
 3) 메시지 본문 : 클라이언트에서 서버로 송신하는 데이터, 폼 페이지에 입력한 내용을 POST로 보낼때 데이터가 들어감
#### 응답 메시지의 구조
 1) 스테이터스 라인 : <HTTP 버전> \<스테이터스 코드> <응답 문구>
 2) 메시지 헤더 : 응답의 부가 정보
 3) 메시지 본문 : 서버에서 클라이언트로 송신하는 데이터, 파일에서 읽은 데이터 혹은 CGI 프로그램의 출력

### 2. 웹 서버의 IP주소를 DNS서버에 조회
#### 1. IP 주소
- 브라우저는 URL을 해독하고 HTTP 메시지를 만들지만 메시지를 네트워크에 송출하는 기능은 없으므로 OS에게 의뢰해서 송신함
- 이때 URL안에 서버의 도메인명에서 IP주소를 추출해야 함
#### TCP/IP의 대략적인 내용
- 여러 PC(네트워크 장비)를 허브에 연결시킨 작은 네트워크를 서브넷이라고 함.
- 서브넷 여러 대를 라우터로 접속하여 전체 네트워크가 만들어 짐
- 'OO동 XX번지' 이런 형태로 네트워크 주소를 할당하게 되는데 동에 해당하는 번호를 서브넷에 할당하고, 번지에 해당하는 번호를 PC에 할당한 것이 네트워크 주소
- 동에 해당하는 번호를 네트워크 번호라고 하고 번지에 해당하는 번호를 호스트 번호라고 함, 이 두 주소를 합쳐서 IP 주소라고 함
- 엑세스 대상의 서버까지 메시지를 운반할 때 이 IP 주소에 따라 판단하고 운반함
- 메시지를 보내면 서브넷안의 허브가 운반하고, 송신측에서 가까운 라우터에 도착함
- 라우터가 메시지를 보낸 상대를 확인해서 다음 라우터를 판단하고 전송함
- 이 동작을 반복해서 대상까지 메시지를 전송함
#### IP 주소
- 실제 IP 주소는 32비트로 8비트씩 점으로 구분하여 10진수로 표기함
- 어느 부분이 네트워크 번호이고 호스트 번호인지 구분할 수 있게 하는 것이 넷마스크
- 10.11.12.13/255.255.255.0 => 슬래시 기준으로 앞부분이 IP 주소, 뒷부분이 넷마스크
- 넷마스크가 255(비트로 따지면 1)인 부분은 네트워크 번호를 나타내고 0인 부분은 호스트 번호를 나타낸다
- 호스트 번호의 비트가 모두 0인 IP 주소는 서브넷 자체를 나타내고 1인 IP 주소는 브로드캐스트(서브넷에 있는 기기전체 대상)를 의미한다 
#### 2. 도메인명과 IP주소
- IP주소를 직접 기억하기는 어려우므로 도메인명을 사용함
- IP주소는 32비트, 즉 4바이트지만, 도메인 명은 수십 바이트에서 최대 255바이트까지의 문자를 취급해야함
- 길이도 길지만 길이가 결정되어있지 않으므로 라우터가 부하되어 네트워크가 느려짐
- 그래서 사람은 이름을 사용하고 라우터는 IP주소를 사용함
- 둘 사이를 알 수 있도록 하는게 DNS
#### 3. Socket 라이브러리가 IP 주소를 찾는 기능 제공
- IP주소를 DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고 응답 메시지를 받는다는 것을 의미
- 이렇게 DNS를 사용해서 IP 주소를 조회하는 것을 네임 리솔루션이라고 하고 리솔루션을 실행하는 DNS 클라이언트를 리졸버라고 부름
- 리졸버는 Socket 라이브러리에 들어있는 프로그램 (Socket 라이브러리 : OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위한 부품들의 집합)
#### 4. 리졸버를 이용하여 DNS 서버를 조회
- 리졸버의 프로그램(함수)명과 웹 서버의 이름을 쓰는 것으로 호출할 수 있음
- <메모리 영역> = gethostbyname("www.lab.cyber.co.kr");
- 리졸버는 응답 메시지안에 IP 주소를 추출하여 메모리 영역에 저장함
- 브라우저는 웹 서버에 메시지를 보낼때 메모리 영역에서 IP 주소를 추출하여 HTTP 리퀘스트 메시지와 함께 OS에 건네주어 송신을 의뢰할 뿐임
#### 5. 리졸버 내부 작동
- 리졸버는 DNS 서버에 의뢰하기 위한 메시지를 작성
- OS 내부의 프로토콜 스택에게 송신을 의뢰 (리졸버도 브라우저처럼 데이터 전송 능력이 없음)
- 프로토콜 스택에서 LAN 어댑터를 통해 DNS 서버로 메시지 송신
- 응답 메시지가 프로토콜 스택, 리졸버를 거쳐서 메모리 영역에 IP 주소가 쓰여짐
- (기본적으로 DNS 서버의 IP 주소는 컴퓨터에 미리 설정 되어있음)

### 3. DNS 서버
#### 1. DNS 서버의 기본 동작
- 조회 메시지는 이름, 클래스, 타입으로 구성
- 이름 : 도메인명
- 클래스 : 초기 DNS 고안당시 인터넷 이외에도 사용하려고 클래스라는 것을 만들었는데 지금은 인터넷을 나타내는 "IN" 빼고 다 소멸됨
- 타입 : 이름에 어떤 타입인지 나타냄 (A면 IP 주소, MX면 메일 배송 목적지)
- DNS 서버는 등록된 정보 중 세 가지 모두 일치하는 것을 찾아서 회답함
#### 2. 도메인의 계층
- 도메인명을 계층으로 분산시켜서 다수의 DNS 서버에 등록하고 다수의 DNS 서버가 연대해서 어디에 정보가 있는지 찾아내는 구조
#### 3. 담당 DNS 서버를 찾아 IP 주소를 가져옴
- 하위 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록하고 상위의 DNS 서버의 IP 주소를 또 상위의 DNS 서버에 등록하는 방식
- 루트 도메인의 DNS 서버를 모든 DNS 서버에 등록함
- 그래서 클라이언트는 DNS 서버에 액세스하면 루트 도메인을 경유하는 것으로 원하는 DNS 서버에 도착할 수 있음
- 클라이언트는 가장 가까이에 있는 DNS 서버(미리 PC에 설정된)에 조회를 요청함
- DNS 서버에는 루트 도메인의 DNS 서버가 등록되어 있으므로 조회메시지를 전달
- 루트 도메인에 해당 도메인명이 없으므로 반송하게 되는데 이때 대신 하위 계층의 도메인을 담당하는 서버의 IP 주소를 반송함
- 그럼 DNS 서버가 받은 주소로 메시지를 조회메시지를 보내고 또 등록되어있지 않으면 대신 하위 계층의 도메인을 담당하는 서버의 IP 주소를 반송
- 이렇게 계층을 따라 하위로 내려가다보면 원하는 DNS 서버에 도달하게 되고 조회한 도메인의 IP 주소를 알 수 있음
#### 4. DNS 서버의 캐시
- DNS 서버는 한 번 조사한 이름을 캐시에 기록하고 조회한 도메인 명에 해당하는 캐시가 있으면 바로 회답하기 때문에 빠름
- DNS 서버에 등록하는 캐시는 유효기간을 설정하고 조회에 회답할 때 정보가 캐시에 저장된 것인지 DNS 서버에서 회답한 것인지 알려줌
### 4. 프로토콜 스택에 메시지 송신을 의뢰
#### 1. 데이터 송,수신 개요
- IP 주소를 알아냈으니 웹 서버에게 메시지를 송신하도록 OS 내부의 프로토콜 스택에 의뢰
- OS 내부의 프로토콜 스택에 메시지 송신을 의뢰할 때는 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출
- 송,수신하는 컴퓨터 사이에 데이터가 지나는 파이프가 있어서 파이프에 데이터를 넣으면 반대쪽으로 나오는 형태
- 파이프의 양 끝은 데이터의 출입구, 소켓
- 서버 측은 소켓을 만들고 소켓에 클라이언트가 연결되기를 기다림
- 1) 소켓 생성
- 2) 서버측의 소켓에 파이프 연결
- 3) 데이터 송, 수신
- 4) 파이프 분리 및 소켓 말소
- 위 네가지 동작은 프로토콜 스택이 하는 일, 브라우저는 의뢰만 함
#### 2. 소켓 작성
- 데이터 송,수신을 의뢰하는 애플리케이션(브라우저)는 DNS 서버에 조회하는 것처럼 Socket 라이브러리의 부품을 호출함
- DNS 서버에 조회할 때는 리졸버를 호출했지만 이번엔 몇 개의 프로그램을 순번대로 호출함
- socket(), connect(), write(), read(), close() 순으로 호출
#### 3. 파이프를 연결하는 접속 단계
- socket()을 통해 소켓을 생성하는데(과정은 챕터2에) 디스크립터라는 것이 반환되어 각 소켓을 식별할 수 있음
- connect()로 서버측의 소켓에 연결하는데 (디스크립터, 서버 IP주소, 포트번호)가 사용됨
- 서버측의 포트번호는 80, 클라이언트측의 포트번호는 프로토콜 스택이 할당해서 접속할 때 서버측에 통지
- 디스크립터 : 애플리케이션이 소켓을 식별하는 것
- IP주소, 포트번호 : 클라이언트와 서버간에 상대의 소켓을 식별하는 것
#### 4. 메시지 송,수신 단계
- write()를 통해 서버측으로 송신함
- write()를 호출할 때 디스크립터와 송신 데이터(리퀘스트 메시지)를 지정함
- read()를 통해 수신하여 수신 버퍼에 응답 메시지를 저장
#### 5. 연결 끊기 단계
- close()를 통해 연결을 끊으면 파이프가 분리되고 소켓도 말소됨
- 본래는 서버측에서 응답 송신이 끝나면 close를 호춯하지만 같은 서버에서 복수의 데이터를 읽을 때 접속과 연결 끊기를 반복하면 비효율적이므로 한번 접속하면 연결을 끊지 않고 주고 받는 방법도 마련되었음 (HTTP 1.1)
- 후자의 방식에서는 리퀘스트할 데이터가 없을 때 브라우저에서 연결 끊기 동작을 수행
